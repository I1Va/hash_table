# Оптимизация работы хэш-таблицы с использованием профилирования

## Аннотация
В данной работе исследуются приемы оптимизации хеш-таблицы, реализованной методом цепочек. Основная цель — выявить «горячие» участки кода с помощью профилирования и улучшить их производительность за счет использования низкоуровневых техник, таких как ассемблерные вставки, `intrinsics`, реализация функций на `nasm`.

Оптимизации будут проводиться итеративно. Каждая новая версия проекта будет включать в себя оптимизации предыдущей:
* `v1` - версия без оптимизаций
* `v2` - версия с компиляторными оптимизациями
* `v3` - версия с intrinsic оптимизацией функции cr32
* `v4` - версия с использованием собственной реализацией функции streq на ассемблере
* `v5` - версия с использованием inline функции streq с ассемблерными вставками
* `v6` - версия с использованием inline хэш-функции cr32 на intrinsic

## Среда и интрументы
* __Процессор:__ Intel Core i5-10300H 2.5GHz
* __Компилятор:__ g++ 13.3.0
* __Среда:__ Ubuntu 24.04
* __Инструменты профилирования:__ perf, hotspot
* __Сборка:__ makefile, python

## Входные данные
Перед началом тестирования хэш таблицы требуется сгенерировать входные данные. В качестве исходника для входных данных был взят текст романа Л. Н. Толстого "Война и мир", находящийся в файле `war_and_peace.txt`.

Подготовленными входными данными являются:
* Список слов для загрузки в хэш таблицу `text.txt`
* Список слов для тестирования хэш таблицы `tests.txt`

Для исследования оптимизаций хэш-таблицы установим:
* Длину каждого списка из входных данных в `40000` слов
* Размер хэш-таблицы в `512` ячеек

Данные константы были подобраны для того, чтобы `load factor` хэш-таблицы был равен `≈15`. В реальности для данное значение `load factor` слишком велико и может привести к длительному линейному поиску в односвязном списке. В данной работе `load factor` был взят неоптимальным специально для возможности применения эффективных оптимизации к функции `strncmp` и достоверного исследования хеш-функции на частоту коллизий.

Для генерации входных данных используйте команду:

```
    python3 run.py gen_tests
```

После выполнения команды будет создана папка `data` с файлами `text.txt` и `tests.txt` с необходимыми входными данными.



## Бенчмаркинг версий
Для измерения времени работы всех версий проекта (`VERSION_O3` - `VERSION_ASM_INSERTION_CR32``) исполните команду
```bash
    python3 run.py versions_benchmarks <кол-во измерений на версию>
```
По умолчанию кол-во измерений на версию равно 20

После выполнения команды в папке `results` появится папка `versions_benchmark.out` с результатами бенчмаркинга с учетом погрешности ($x_{mean} ± 	\sigma_{x_{mean}}$). При расчете использовались формулы:

$$x_{mean} = \frac{\Sigma_{1}^{N}x_i}{n} $$

$$s = \sqrt{\frac{1}{N - 1}\Sigma_{1}^{N}(x_i - x_{mean})^2}$$

$$\sigma_{x_{mean}} = \frac{s}{\sqrt{N}}$$

$$\sigma_{x_{mean}} = \frac{s}{\sqrt{N}}$$

Рядом с результатом измерения будет выведена информация об абсолютной погрешности:
`(error : XX.XX%)`. Для уменьшения относительной погрешности рекомендуется увеличить `<кол-во измерений на версию>`



## Исследование функций хэширования
Перед началом процесса оптимизации рассмотрим несколько хэш-функций и отберем самую лучшую.
Все хэш-функции имеют сигнатуру
```c++
uint64_t hash_function(char *key_32b, const size_t len);
```
Выбор самой лучшей хэш-функции будет определятся несколькими критериями:
* __Величина стандартного расредления коллизий__. Чем меньше величина, тем равномернее будут распределяться значения по хэш-таблице, что будет способствовать ускорению поиска значений.
* __intrinsic Поддержка__. Для некоторых хэш-функций были созданы `intrinsics`, использование которых значительно ускоряет их работу.

### Хэш-функция : "Первый символ"
__Реализация__
```c++
uint64_t first_char_hash_func(char *key, const size_t len) {
    return (uint64_t) key[0];
}
```

![image](results/hash_funcs/img/fchar.png)

__Стандартное отклонение__ : 71.08

Функция не покрывает весь диапазон значений. Большинство значений приходятся на промежуток `[50, 130]`. Не смотря на свою большую скорость, функция неэффективна из-за плохого распределения своих значений.


### Хэш-функция : "Полиномиальная"
__Реализация__
```c++
uint64_t polynom_hash_func(char *key, const size_t len) {
    uint64_t hash = 0;
    for (size_t i = 0; i < len; i++) {
        hash = (hash * 255 + (uint64_t) key[i]) % (1e9 + 7);
    }
    return hash;
}
```
![image](results/hash_funcs/img/poly.png)

__Стандартное отклонение__ : 3.96

Функция достаточно хорошо покрывает весь диапазон значений, но у неё `intrinsic` поддержки.


### Хэш-функция : "FNV (Fowler–Noll–Vo)"

__Реализация__
```c++
uint64_t fnv1a_hash(char *key, const size_t len) {
    const uint64_t FNV_prime = 0x01000193;
    uint64_t hash = 0x811C9DC5;
    const uint8_t *bytes = (const uint8_t *) key;

    for (size_t i = 0; i < len; i++) {
        hash ^= bytes[i];
        hash *= FNV_prime;
    }
    return hash;
}
```
![image](results/hash_funcs/img/fnv.png)

__Стандартное отклонение__ : 3.92

Хорошая с точки зрения распределения хэш-функция. Есть `intrinsic` поддержка.


### Хэш-функция : "CR32"

Реализация
```c++
uint64_t crc32_hash_func(char *key, const size_t len) {
    const uint64_t CR32_POLY = 0x04C11DB7;
    const unsigned char *buffer = (const unsigned char*) key;
    uint64_t crc = (uint64_t) -1;

    for (size_t i = 0; i < len; i++) {
        crc = crc ^ (uint64_t) (*buffer++ << 24);
        for( int bit = 0; bit < 8; bit++ )
        {
            if( crc & (1L << 31)) crc = (crc << 1) ^ CR32_POLY;
            else                  crc = (crc << 1);
        }
    }

    return ~crc;
}
```
![image](results/hash_funcs/img/cr32.png)

__Стандартное отклонение__ : 4.07

Обладает распределением чуть хуже `FNV` функции, но поддерживает `intrinsic` реализацию.

### Хэш-функция : "CR32_intrinsic"
Забегая немного вперед, покажу потенциал `intrinsic` реализации функции `CR32`, тем самым обосновав ее дальнейший выбор.

__Реализация__
```c++
uint64_t crc32_intrinsic_hash_func(char *key, const size_t len __attribute__((unused))) {
    uint64_t crc = 0;

    crc = _mm_crc32_u64(crc, *(uint64_t*) key + 0);
    crc = _mm_crc32_u64(crc, *(uint64_t*) key + 1);
    crc = _mm_crc32_u64(crc, *(uint64_t*) key + 2);
    crc = _mm_crc32_u64(crc, *(uint64_t*) key + 3);

    return crc;
}
```

![image](results/hash_funcs/img/cr32_intrinsic.png)

__Стандартное отклонение__ : 4.66
Обладает не самым хорошим распределением, но выйгрывает за счет скорости.


## Итоговые результаты сравнения
Хэш функции были протестированы на входных данных с флагом компиляции `-O3`

Хэш-функция         |   ticks   | стандартное отклонение
--------------------|-----------|-----------------------
cr32_intrinsic      | 235224    | 4.66
cr32                | 19512686  | 4.07
fchar               | 195208    | 71.08
fnv                 | 1859450   | 3.92
poly                | 7821120   | 3.96

Эффективнее всего показала себя хэш-функция `cr32_intrinsic`. Поэтому в дальнейшем будем использовать именно ее.

## Оптимизации хэш-таблицы
### v1

Стартовая версия без оптимизаций. Спефика входных данных не учтена.
Вместо `cr32_intrinsic` выбрана хэш-функция `cr32`, чтобы при дальнейшем анализе показать, что неэффективная реализация хэш-функции может быть узким местом во всей программе.

Флаги компиляции: `-O0 -march=native`

__Flame graph__
![image](/results/screenshots/v0_flame.png)
Действительно, хэш-функция `cr32` оказалась самым узким местом программы.

__Perf hist__
![image](/results/screenshots/v0_perfhist.png)

### VERSION_O3
Отличие от предыдущей версии состоит в наличии стандратных оптимизаций, действующих при комипляции с флагами `-O3 -mtune=native`.

Флаги компиляции: `-O3 -march=native -mtune=native`

__Результаты__

Версия    |Ticks                                        |Ускорение относительно предыдущей версии|
----------|---------------------------------------------|----------------------------------------|
VERSION_O3 |61200123.2 ± 749884.90514                   |        -                               |

__Flame graph__
![image](/results/screenshots/v1_flame.png)

__Perf hist__
![image](/results/screenshots/v1_perfhist.png)

При анализе `Perf hist` было замечено, что компилятор ускорил хэш-функцию `cr32` более чем на 30%.
Изучим техники, примененные компилятором при данной оптимизации

__godbolt template__ : https://godbolt.org/z/8xsj9Mqz3

Первой техникой компилятора было скоращение работы с памятью. В неоптимизированном ассемблерном коде наблюдается частое использование переменных, хранящихся на стековом фрейме в то время, как оптимизированная версия его не использует.
![image](/results/screenshots/O3_cr32_opti_mem.png)

Второй техникой была развертка внутреннего цикла.
![image](/results/screenshots/O3_unroll.png)


Данная техника способствовала уменьшению `branch-misses` на 15%.
![image](/results/screenshots/v1_misses.png)


### VERSION_INTINSIC
Не смотря на компиляторные оптимизации, примененные в `VERSION_O3`, хэш-функция `cr32` по-прежнему остается самым узким местом программы. В `VERSION_INTINSIC` воспользуемся `intrinsic` реализацией функции `cr32`.

__Результаты__
Версия    |Ticks                                        |Ускорение относительно предыдущей версии|
----------|---------------------------------------------|----------------------------------------|
VERSION_O3 | 61200123.2 ± 749884.90514                   |         -               |
VERSION_INTINSIC | 18481990.2 ± 458314.9905                    |         69.8% ± 1.1%                   |


__Perf hist__
![image](/results/screenshots/v2_perfhist.png)


Анализ `perf hist` показал, что примененная оптимизация дала ощутимый эффект: `cr32` стала занимать всего `2.41% overhead`. Теперь стандратная функция `strncmp_avx2` является узким местом программы с `30.12% overhead`.

### VERSION_MY_STREQ
Напишем свою функцию `streq_32b` на ассемблере и воспользуемся ею в текущей версии.
Реализация `streq_32b` опиралась на специфику входных данных (все слова имеют длину <= 32). В ней строки загружаются в вектора `ymm` по 256 байт и сравниваются одной ассемблерной инструкцией `vpcmpeqb`. Важной деталью реализации является использование инструкции `vmovdqa`, работающей с выравненными по 32 байта данными.

__Реализация__
```nasm
streq_32b:
    vmovdqa ymm0, [rdi]
    xor rax, rax
    vptest ymm0, [rsi]
    seta al

    ret
```

__Результаты__
Версия    |Ticks                                        |Ускорение относительно предыдущей версии|
----------|---------------------------------------------|----------------------------------------|
VERSION_O3 | 61200123.2 ± 749884.90514                   |         -              |
VERSION_INTINSIC | 18481990.2 ± 458314.9905                    |         69.8% ± 1.1%                   |
VERSION_MY_STREQ | 15052046.46667 ± 278157.57937               |         18.6% ± 3.5%                   |

__Perf hist__
![image](/results/screenshots/v3_perfhist.png)

Было получено ускорение функции сравнения строк более чем на `8%`. Но несмотря на это, она по-прежнему остается самой горячей. Попробуем исправить это в следующей версии.

### VERSION_ASM_INSERTION_STREQ
Реализую inline версию функции `streq_32b` с помощью ассемблерных вставок

__Реализация__
```c++
__attribute__((unused))
inline int streq_32b_inline(const char *str1, const char *str2) {
    int res = 0;
    __asm__(".intel_syntax noprefix\n"
            "vmovdqa ymm0, [%1]\n"
            "xor rax, rax\n"
            "vptest ymm0, [%2]\n"
            "seta al\n"

            : "=a"(res)
            : "S"(str1),
              "D"(str2)
            : "ymm0", "cc");

    return res;
}
```

Оптимизация дала незначительный результат.
Уменьшение затрат на call компенсируется увеличением количеством `cache-misses` и `branch-misses`

![image](/results/screenshots/cache_misses_cmp.png)

# Итоговые результаты:

Версия                      |Ticks                                           |Ускорение относительно VERSION_03       |
----------------------------|------------------------------------------------|----------------------------------------|
VERSION_03                  | 131577240.95667 ± 601790.72268 (error : 0.46%) |        --
VERSION_INTINSIC            | 17477071.52 ± 110866.1143 (error : 0.63%)      | 7.53 ± 0.06 (0.78 %)
VERSION_MY_STREQ            | 15814945.83667 ± 147313.02277 (error : 0.93%)  | 8.32 ± 0.09 (1.04 %)
VERSION_ASM_INSERTION_STREQ | 15596619.59667 ± 125390.22226 (error : 0.8%)   | 8.44 ± 0.08 (0.92 %)
VERSION_ASM_INSERTION_CR32  | 15814835.62 ± 144791.63037 (error : 0.92%)     | 8.32 ± 0.08 (1.02 %)
VERSION_INLINE_INTINSIC_CR32| 15208266.2 ± 120973.23491 (error : 0.8%)       | 8.65 ± 0.08 (0.92 %)



# Вывод:
После процесса последовательных оптимизаций работа с хеш-таблицей была ускорена в 8.5 раз. Было продемонстрировано, что при должном понимании ограничений на входные данные появляется возможность проводить более агрессивные оптимизации, которые не может себе позволить компилятор. Также был показан ощутимый эффект применения ассемблерных оптимизаций.

В образовательных целях мы пренебрегли очень важным фактором скорости работы хеш-таблицы, ее `load factor`.
Но реальных проектах перед началом ассемблерных оптимизаций очень важно провести алгоритмический анализ. Ведь некоторые узкие в алгоритмическом смысле места могут быть нераспознаны к примеру профилировщиком.
